// Machine Dialect Grammar for LARK Parser
// This grammar should match the exact syntax of the main parser
// CRITICAL: 100% feature parity with main parser is MANDATORY

start: program

// Allow empty programs (just whitespace/comments)
program: utility_def* statement_list
       | utility_def+  // Just utility definitions
       |               // Completely empty program

// Utility definitions (markdown style) - parsed but treated as metadata
utility_def: MARKDOWN_HEADER HTML_BLOCK? INPUTS_SECTION? OUTPUTS_SECTION?

MARKDOWN_HEADER: /###\s+\*\*[^*]+\*\*:\s*`[^`]+`[^\n]*/
HTML_BLOCK: /<details>[\s\S]*?<\/details>/
INPUTS_SECTION: /####\s+Inputs:[^\n]*(\n-[^\n]*)*/
OUTPUTS_SECTION: /####\s+Outputs:[^\n]*(\n-[^\n]*)*/

// Allow statements with or without periods, or single expressions
statement_list: (statement ".")+
              | statement        // Single statement without period
              | expression       // Bare expression

statement: set_stmt
         | give_back_stmt
         | say_stmt
         | tell_stmt      // Add Tell as alias for Say
         | if_stmt
         | when_stmt      // Add When as alias for If
         | use_stmt       // Add Use (replaces Call)
         | call_stmt      // Keep for backward compatibility
         | action_stmt
         | interaction_stmt

// Statements - includes type annotations
set_stmt: "Set"i identifier "to"i expression
        | "Set"i identifier "as"i type_name "to"i expression                   // Type annotations
        | "Set"i identifier "using"i identifier ("with"i expression_list)?     // Set using with positional args
        | "Set"i identifier "using"i identifier ("where"i named_args)?         // Set using with named args

// Type names for type annotations
type_name: "Integer"i | "Float"i | "Number"i | "Text"i | "String"i | "Boolean"i | "Bool"i | "URL"i | IDENTIFIER
give_back_stmt: ("Give"i "back"i | "Gives"i "back"i) expression
say_stmt: "Say"i expression
tell_stmt: "Tell"i expression  // Alias for Say
use_stmt: "Use"i identifier ("with"i expression_list)?  // Modern syntax
        | "Use"i identifier ("where"i named_args)?      // Named arguments
call_stmt: "Call"i identifier ("with"i expression_list)?  // Deprecated but kept for compatibility

// Support for When as alias for If
when_stmt: "When"i expression "then"i ":" BLOCK_CONTENT? otherwise_clause?
otherwise_clause: "Otherwise"i ":" BLOCK_CONTENT?

// Action and Interaction with simplified blocks
// For CFG validation, we'll accept the structure but not fully parse blocks
action_stmt: "Action"i IDENTIFIER ("with"i parameter_list)? ":" BLOCK_CONTENT?
interaction_stmt: "Interaction"i IDENTIFIER ("with"i parameter_list)? ":" BLOCK_CONTENT?

// If statement with simplified blocks
if_stmt: "If"i expression "then"i ":" BLOCK_CONTENT? else_clause?
else_clause: ("Else"i | "Otherwise"i) ":" BLOCK_CONTENT?

// Parameters - supports "as Type" syntax for actions/interactions
parameter_list: parameter ("," parameter)*
parameter: identifier ("as"i IDENTIFIER)? ("=" expression)?

// Named arguments for function calls
named_args: named_arg ("," named_arg)*
named_arg: identifier "is"i expression

expression_list: expression ("," expression)*

// Expressions
expression: conditional_expr
          | or_expr

conditional_expr: or_expr "if"i or_expr "else"i or_expr

or_expr: and_expr ("or"i and_expr)*

and_expr: not_expr ("and"i not_expr)*

not_expr: "not"i not_expr
        | comparison

comparison: arith_expr (comp_op arith_expr)?

comp_op: "<=" | ">=" | "<" | ">"
       | "equals"i
       | "is"i "equal"i "to"i
       | "is"i "the"i "same"i "as"i
       | "is"i "not"i "equal"i "to"i
       | "does"i "not"i "equal"i
       | "is"i "different"i "from"i
       | "is"i "not"i type_name        // Type checking (negated)
       | "is"i "not"i
       | "is"i "strictly"i "equal"i "to"i
       | "is"i "exactly"i "equal"i "to"i
       | "is"i "identical"i "to"i
       | "is"i "not"i "strictly"i "equal"i "to"i
       | "is"i "not"i "exactly"i "equal"i "to"i
       | "is"i "not"i "identical"i "to"i
       | "is"i "greater"i "than"i "or"i "equal"i "to"i
       | "is"i "less"i "than"i "or"i "equal"i "to"i
       | "is"i "greater"i "than"i
       | "is"i "less"i "than"i
       | "is"i "more"i "than"i         // Natural language >
       | "is"i "under"i                // Natural language <
       | "is"i "at"i "least"i          // Natural language >=
       | "is"i "at"i "most"i           // Natural language <=
       | "is"i type_name                // Type checking

arith_expr: term (("+"|"-") term)*

term: power (("*"|"/") power)*

power: factor ("^" factor)*

factor: "-" factor
      | atom

atom: "(" expression ")"
    | literal
    | identifier

// Identifier can be plain, backtick-wrapped, or bold-wrapped
identifier: IDENT
          | BACKTICK_IDENT

// Literals - parse with underscores as complete tokens
literal: LITERAL_FLOAT
       | LITERAL_INT
       | LITERAL_STRING
       | LITERAL_TRUE
       | LITERAL_FALSE
       | LITERAL_YES    // Add Yes as boolean true
       | LITERAL_NO     // Add No as boolean false
       | LITERAL_EMPTY
       | LITERAL_URL

// Literal patterns - these are complete tokens including underscores
// Higher priority than IDENT to ensure they match first
// Support scientific notation for floats
LITERAL_FLOAT.3: /_-?\d+\.\d+([eE][+-]?\d+)?_/ | /_-?\d+[eE][+-]?\d+_/
LITERAL_INT.3: /_-?\d+_/
// Support single, double, and triple-quoted strings
LITERAL_STRING.3: /_"""[\s\S]*?"""_|_'''[\s\S]*?'''_|_"(?:[^"\\]|\\.)*"_|_'(?:[^'\\]|\\.)*'_/
LITERAL_TRUE.3: /_true_/i
LITERAL_FALSE.3: /_false_/i
LITERAL_YES.3: /_yes_/i       // Yes literal
LITERAL_NO.3: /_no_/i         // No literal
LITERAL_EMPTY.3: /_empty_/i
LITERAL_URL.3: /_https?:\/\/[^\s]+_/

// Backtick identifier - can contain spaces and special characters
BACKTICK_IDENT.2: /`[^`]+`/

// Use IDENT instead of IDENTIFIER to avoid conflicts with literal patterns
IDENT: /[a-zA-Z][a-zA-Z0-9_]*|[a-zA-Z_][a-zA-Z0-9_]+/
// This pattern ensures single underscore is not matched as identifier

// For places where IDENTIFIER was used
IDENTIFIER: IDENT

// Block content - matches everything after : until end or next statement
// This is a simplified approach for CFG validation
// Supports nested blocks with multiple > markers
BLOCK_CONTENT.2: /(\n[ \t]*>+[^\n]*)+/

COMMENT: /#[^\n]*/

%import common.WS
%ignore WS
%ignore COMMENT
