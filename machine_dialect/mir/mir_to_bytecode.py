"""MIR to Bytecode code generator.

This module generates bytecode from MIR (Middle-level Intermediate Representation).
It performs register allocation, stack scheduling, and efficient bytecode generation.
"""

from typing import Any

from machine_dialect.codegen.isa import Opcode
from machine_dialect.codegen.objects import Chunk, ChunkType, Module
from machine_dialect.mir.basic_block import BasicBlock
from machine_dialect.mir.debug_info import DebugInfo, LineMapping
from machine_dialect.mir.mir_function import MIRFunction
from machine_dialect.mir.mir_instructions import (
    Assert,
    BinaryOp,
    Call,
    ConditionalJump,
    Copy,
    Jump,
    LoadConst,
    LoadVar,
    MIRInstruction,
    Nop,
    Phi,
    Pop,
    Print,
    Return,
    Scope,
    Select,
    StoreVar,
    UnaryOp,
)
from machine_dialect.mir.mir_module import MIRModule
from machine_dialect.mir.mir_types import MIRType
from machine_dialect.mir.mir_values import Constant, MIRValue, Temp, Variable
from machine_dialect.mir.register_allocation import RegisterAllocation, RegisterAllocator


class StackSlot:
    """Represents a stack slot for locals."""

    def __init__(self, index: int, name: str, mir_type: MIRType) -> None:
        """Initialize a stack slot.

        Args:
            index: Slot index.
            name: Variable name.
            mir_type: MIR type.
        """
        self.index = index
        self.name = name
        self.mir_type = mir_type


class BytecodeGenerator:
    """Generates bytecode from MIR."""

    def __init__(self) -> None:
        """Initialize the bytecode generator."""
        self.module: Module | None = None
        self.current_chunk: Chunk | None = None
        self.current_function: MIRFunction | None = None

        # Stack slot allocation with register optimization
        self.local_slots: dict[MIRValue, StackSlot] = {}
        self.next_slot_index = 0
        self.max_stack_depth = 0
        self.current_stack_depth = 0

        # Register allocation result
        self.register_allocation: RegisterAllocation | None = None

        # Label to offset mapping
        self.label_offsets: dict[str, int] = {}
        self.pending_jumps: list[tuple[int, str]] = []

        # Constant pool
        self.constants: list[Any] = []
        self.constant_indices: dict[Any, int] = {}

        # Debug information
        self.debug_info: DebugInfo | None = None
        self.current_source_line: int = 0

    def generate_module(self, mir_module: MIRModule, debug_info: DebugInfo | None = None) -> Module:
        """Generate bytecode module from MIR module.

        Args:
            mir_module: The MIR module.
            debug_info: Optional debug information.

        Returns:
            Generated bytecode module.
        """
        # Store debug info
        self.debug_info = debug_info

        # Generate main chunk first
        main_chunk = Chunk("__main__")

        # Create bytecode module with main chunk
        self.module = Module(mir_module.name, main_chunk)

        # Find and generate main function
        main_func = mir_module.get_function("main")
        if main_func:
            self._generate_function_inline(main_func, main_chunk)
        else:
            # Generate empty main chunk
            main_chunk.write_byte(Opcode.HALT)

        # Generate other functions
        for func_name, func in mir_module.functions.items():
            if func_name != "main":
                bytecode_func = self._generate_function(func)
                self.module.add_function(func_name, bytecode_func)

        return self.module

    def _generate_function(self, mir_func: MIRFunction) -> Chunk:
        """Generate bytecode for a function.

        Args:
            mir_func: The MIR function.

        Returns:
            Generated bytecode function.
        """
        # Create function chunk
        func_chunk = Chunk(mir_func.name, ChunkType.FUNCTION)
        func_chunk.num_params = len(mir_func.params)

        # Generate into function chunk
        self._generate_function_inline(mir_func, func_chunk)

        return func_chunk

    def _generate_function_inline(self, mir_func: MIRFunction, chunk: Chunk) -> None:
        """Generate bytecode for a function inline into a chunk.

        Args:
            mir_func: The MIR function.
            chunk: The chunk to generate into.
        """
        self.current_function = mir_func
        self.current_chunk = chunk
        self.local_slots.clear()
        self.next_slot_index = 0

        # Perform register allocation
        allocator = RegisterAllocator(mir_func)
        self.register_allocation = allocator.allocate()
        self.max_stack_depth = 0
        self.current_stack_depth = 0
        self.label_offsets.clear()
        self.pending_jumps.clear()

        # Allocate slots for parameters
        for param in mir_func.params:
            self._allocate_slot(param)

        # Allocate slots for locals (skip in main function - they're globals)
        if mir_func.name != "main":
            for local_var in mir_func.locals.values():
                self._allocate_slot(local_var)

        # Allocate slots for temporaries
        for temp in mir_func.temporaries:
            self._allocate_slot(temp)

        # Collect all variables used in instructions (for SSA-versioned variables)
        for block in mir_func.cfg.blocks.values():
            # Check phi nodes
            for phi in block.phi_nodes:
                if isinstance(phi.dest, Variable | Temp):
                    self._allocate_slot(phi.dest)
                for val, _ in phi.incoming:
                    if isinstance(val, Variable | Temp):
                        self._allocate_slot(val)

            # Check regular instructions
            for inst in block.instructions:
                # Check all uses and defs
                for val in inst.get_uses():
                    if isinstance(val, Variable | Temp):
                        # Skip variables in main function (they're globals)
                        if not (mir_func.name == "main" and isinstance(val, Variable)):
                            self._allocate_slot(val)
                for val in inst.get_defs():
                    if isinstance(val, Variable | Temp):
                        # Skip variables in main function (they're globals)
                        if not (mir_func.name == "main" and isinstance(val, Variable)):
                            self._allocate_slot(val)

        # Set the number of locals in the chunk for Frame initialization
        chunk.num_locals = self.next_slot_index

        # Generate code only for reachable blocks
        # Unreachable blocks (e.g., merge blocks after branches that both return)
        # should not generate bytecode as they would corrupt the instruction stream
        if mir_func.cfg.entry_block:
            # Find all reachable blocks using breadth-first search from entry
            reachable: set[BasicBlock] = set()
            to_visit = [mir_func.cfg.entry_block]

            while to_visit:
                block = to_visit.pop(0)
                if block in reachable:
                    continue
                reachable.add(block)
                to_visit.extend(block.successors)

            # Generate entry block first
            self._generate_block(mir_func.cfg.entry_block)

            # Generate other reachable blocks
            # Skip unreachable blocks to avoid generating dead code that could
            # be misinterpreted as operands for other instructions
            for block in mir_func.cfg.blocks.values():
                if block != mir_func.cfg.entry_block and block in reachable:
                    self._generate_block(block)

        # Resolve pending jumps
        self._resolve_jumps()

        # Add final halt if needed
        if chunk.bytecode and chunk.bytecode[-1] != Opcode.RETURN:
            chunk.write_byte(Opcode.HALT)
        elif not chunk.bytecode:
            chunk.write_byte(Opcode.HALT)

    def _generate_block(self, block: BasicBlock) -> None:
        """Generate bytecode for a basic block.

        Args:
            block: The basic block.
        """
        if not self.current_chunk:
            return

        # Record label offset
        self.label_offsets[block.label] = self.current_chunk.current_position()

        # Generate instructions, but handle phi copies before jumps
        for inst in block.instructions:
            # Before generating a jump, handle phi nodes in successors
            if isinstance(inst, Jump | ConditionalJump):
                for succ in block.successors:
                    for phi in succ.phi_nodes:
                        # Find the value for this predecessor
                        for incoming_val, incoming_label in phi.incoming:
                            if incoming_label == block.label:
                                # Generate code to copy incoming_val to phi.dest
                                self._load_from_value(incoming_val)
                                self._store_to_value(phi.dest)
                                break

            # Now generate the instruction (including the jump)
            self._generate_instruction(inst)

    def _generate_instruction(self, inst: MIRInstruction) -> None:
        """Generate bytecode for a MIR instruction.

        Args:
            inst: The MIR instruction.
        """
        if not self.current_chunk:
            return

        # Track source location if debug info available
        if self.debug_info:
            location = self.debug_info.get_instruction_location(inst)
            if location:
                # Add line mapping
                bytecode_offset = self.current_chunk.current_position()
                line_mapping = LineMapping(bytecode_offset, location.line)
                self.debug_info.add_line_mapping(line_mapping)
                self.current_source_line = location.line

        if isinstance(inst, LoadConst):
            self._gen_load_const(inst)
        elif isinstance(inst, LoadVar):
            self._gen_load_var(inst)
        elif isinstance(inst, StoreVar):
            self._gen_store_var(inst)
        elif isinstance(inst, Copy):
            self._gen_copy(inst)
        elif isinstance(inst, BinaryOp):
            self._gen_binary_op(inst)
        elif isinstance(inst, UnaryOp):
            self._gen_unary_op(inst)
        elif isinstance(inst, Jump):
            self._gen_jump(inst)
        elif isinstance(inst, ConditionalJump):
            self._gen_conditional_jump(inst)
        elif isinstance(inst, Call):
            self._gen_call(inst)
        elif isinstance(inst, Return):
            self._gen_return(inst)
        elif isinstance(inst, Print):
            self._gen_print(inst)
        elif isinstance(inst, Pop):
            self._gen_pop(inst)
        elif isinstance(inst, Select):
            self._gen_select(inst)
        elif isinstance(inst, Assert):
            self._gen_assert(inst)
        elif isinstance(inst, Phi):
            # Phi nodes are handled during SSA deconstruction
            pass
        elif isinstance(inst, Scope):
            # Scope instructions are hints, no code generated
            pass
        elif isinstance(inst, Nop):
            self.current_chunk.write_byte(Opcode.NOP)
        # Other instructions can be added as needed

    def _gen_load_const(self, inst: LoadConst) -> None:
        """Generate code for LoadConst.

        Args:
            inst: The LoadConst instruction.
        """
        if not self.current_chunk:
            return

        # Add constant to pool
        const_idx = self._add_constant(inst.constant.value)

        # Generate LOAD_CONST
        self.current_chunk.write_byte(Opcode.LOAD_CONST)
        self.current_chunk.write_u16(const_idx)
        self._push_stack()

        # Store to destination
        self._store_to_value(inst.dest)

    def _gen_load_var(self, inst: LoadVar) -> None:
        """Generate code for LoadVar.

        Args:
            inst: The LoadVar instruction.
        """
        if not self.current_chunk:
            return

        # Load from variable slot
        self._load_from_value(inst.var)

        # Store to destination
        self._store_to_value(inst.dest)

    def _gen_store_var(self, inst: StoreVar) -> None:
        """Generate code for StoreVar.

        Args:
            inst: The StoreVar instruction.
        """
        if not self.current_chunk:
            return

        # Load source value
        self._load_from_value(inst.source)

        # Store to variable
        self._store_to_value(inst.var)

    def _gen_copy(self, inst: Copy) -> None:
        """Generate code for Copy.

        Args:
            inst: The Copy instruction.
        """
        if not self.current_chunk:
            return

        # Load source
        self._load_from_value(inst.source)

        # Store to destination
        self._store_to_value(inst.dest)

    def _gen_binary_op(self, inst: BinaryOp) -> None:
        """Generate code for BinaryOp.

        Args:
            inst: The BinaryOp instruction.
        """
        if not self.current_chunk:
            return

        # Load operands
        self._load_from_value(inst.left)
        self._load_from_value(inst.right)

        # Generate operation
        op_map = {
            "+": Opcode.ADD,
            "-": Opcode.SUB,
            "*": Opcode.MUL,
            "/": Opcode.DIV,
            "%": Opcode.MOD,
            "**": Opcode.POW,  # Power operator
            "^": Opcode.XOR,  # Bitwise XOR
            "&": Opcode.BIT_AND,  # Bitwise AND
            "|": Opcode.BIT_OR,  # Bitwise OR
            "<<": Opcode.SHL,  # Shift left
            ">>": Opcode.SHR,  # Shift right
            "==": Opcode.EQ,
            "!=": Opcode.NEQ,
            "===": Opcode.STRICT_EQ,
            "!==": Opcode.STRICT_NEQ,
            "<": Opcode.LT,
            ">": Opcode.GT,
            "<=": Opcode.LTE,
            ">=": Opcode.GTE,
            "and": Opcode.AND,
            "or": Opcode.OR,
            "&&": Opcode.AND,  # Also accept && for AND
            "||": Opcode.OR,  # Also accept || for OR
        }

        if inst.op in op_map:
            self.current_chunk.write_byte(op_map[inst.op])
            self._pop_stack()  # Two operands become one result
        else:
            # Unknown operator, generate error
            raise ValueError(f"Unknown binary operator: {inst.op}")

        # Store result
        self._store_to_value(inst.dest)

    def _gen_unary_op(self, inst: UnaryOp) -> None:
        """Generate code for UnaryOp.

        Args:
            inst: The UnaryOp instruction.
        """
        if not self.current_chunk:
            return

        # Load operand
        self._load_from_value(inst.operand)

        # Generate operation
        if inst.op == "-":
            self.current_chunk.write_byte(Opcode.NEG)
        elif inst.op == "not" or inst.op == "!":
            self.current_chunk.write_byte(Opcode.NOT)
        elif inst.op == "~":
            self.current_chunk.write_byte(Opcode.BIT_NOT)
        else:
            raise ValueError(f"Unknown unary operator: {inst.op}")

        # Store result
        self._store_to_value(inst.dest)

    def _gen_jump(self, inst: Jump) -> None:
        """Generate code for Jump.

        Args:
            inst: The Jump instruction.
        """
        if not self.current_chunk:
            return

        # Generate jump with placeholder offset
        self.current_chunk.write_byte(Opcode.JUMP)
        jump_offset = self.current_chunk.current_position()
        self.current_chunk.write_i16(0)  # Placeholder

        # Record for later resolution
        self.pending_jumps.append((jump_offset, inst.label))

    def _gen_conditional_jump(self, inst: ConditionalJump) -> None:
        """Generate code for ConditionalJump.

        Args:
            inst: The ConditionalJump instruction.
        """
        if not self.current_chunk:
            return

        # Load condition
        self._load_from_value(inst.condition)

        # Jump to false branch if condition is false
        self.current_chunk.write_byte(Opcode.JUMP_IF_FALSE)
        false_jump_offset = self.current_chunk.current_position()
        self.current_chunk.write_i16(0)  # Placeholder
        self._pop_stack()

        # Jump to true branch (unconditional since we only get here if condition was true)
        self.current_chunk.write_byte(Opcode.JUMP)
        true_jump_offset = self.current_chunk.current_position()
        self.current_chunk.write_i16(0)  # Placeholder

        # Record jumps
        self.pending_jumps.append((true_jump_offset, inst.true_label))
        if inst.false_label:
            self.pending_jumps.append((false_jump_offset, inst.false_label))
        else:
            # Fall through - patch to next instruction
            next_offset = self.current_chunk.current_position()
            self.current_chunk.patch_jump(false_jump_offset, next_offset)

    def _gen_call(self, inst: Call) -> None:
        """Generate code for Call.

        Args:
            inst: The Call instruction.
        """
        if not self.current_chunk:
            return

        # Push function
        func_name = inst.func.name
        name_idx = self._add_constant(func_name)
        self.current_chunk.write_byte(Opcode.LOAD_FUNCTION)
        self.current_chunk.write_u16(name_idx)
        self._push_stack()

        # Push arguments
        for arg in inst.args:
            self._load_from_value(arg)

        # Generate call
        self.current_chunk.write_byte(Opcode.CALL)
        self.current_chunk.write_byte(len(inst.args))

        # Adjust stack (function + args consumed, result produced if any)
        for _ in range(len(inst.args) + 1):
            self._pop_stack()
        if inst.dest:
            self._push_stack()
            self._store_to_value(inst.dest)

    def _gen_return(self, inst: Return) -> None:
        """Generate code for Return.

        Args:
            inst: The Return instruction.
        """
        if not self.current_chunk:
            return

        if inst.value:
            self._load_from_value(inst.value)
        else:
            # Push null for void return
            const_idx = self._add_constant(None)
            self.current_chunk.write_byte(Opcode.LOAD_CONST)
            self.current_chunk.write_u16(const_idx)
            self._push_stack()

        self.current_chunk.write_byte(Opcode.RETURN)

    def _gen_print(self, inst: Print) -> None:
        """Generate code for Print.

        Args:
            inst: The Print instruction.
        """
        if not self.current_chunk:
            return

        # Load value to print
        self._load_from_value(inst.value)

        # Call built-in print
        name_idx = self._add_constant("print")
        self.current_chunk.write_byte(Opcode.LOAD_FUNCTION)
        self.current_chunk.write_u16(name_idx)
        self._push_stack()

        # Swap function and argument
        self.current_chunk.write_byte(Opcode.SWAP)

        # Call with 1 argument
        self.current_chunk.write_byte(Opcode.CALL)
        self.current_chunk.write_byte(1)

        # Pop result (print returns None)
        self._pop_stack()
        self._pop_stack()
        self.current_chunk.write_byte(Opcode.POP)

    def _gen_pop(self, inst: Pop) -> None:
        """Generate code for Pop instruction.

        Args:
            inst: The Pop instruction.
        """
        if not self.current_chunk:
            return

        # Load the value onto the stack
        self._load_from_value(inst.value)

        # Generate POP to discard it
        self.current_chunk.write_byte(Opcode.POP)
        self._pop_stack()

    def _gen_select(self, inst: Select) -> None:
        """Generate code for Select (ternary).

        Args:
            inst: The Select instruction.
        """
        if not self.current_chunk:
            return

        # Load condition
        self._load_from_value(inst.condition)

        # Jump if false
        self.current_chunk.write_byte(Opcode.JUMP_IF_FALSE)
        false_jump = self.current_chunk.current_position()
        self.current_chunk.write_i16(0)  # Placeholder
        self._pop_stack()

        # True branch
        self._load_from_value(inst.true_val)
        self.current_chunk.write_byte(Opcode.JUMP)
        end_jump = self.current_chunk.current_position()
        self.current_chunk.write_i16(0)  # Placeholder

        # False branch
        false_offset = self.current_chunk.current_position()
        self._load_from_value(inst.false_val)

        # End
        end_offset = self.current_chunk.current_position()

        # Patch jumps
        self._patch_jump(false_jump, false_offset)
        self._patch_jump(end_jump, end_offset)

        # Store result
        self._store_to_value(inst.dest)

    def _gen_assert(self, inst: Assert) -> None:
        """Generate code for Assert.

        Args:
            inst: The Assert instruction.
        """
        if not self.current_chunk:
            return

        # Load condition
        self._load_from_value(inst.condition)

        # Jump if true (assertion passes)
        self.current_chunk.write_byte(Opcode.JUMP_IF_FALSE)
        pass_jump = self.current_chunk.current_position()
        self.current_chunk.write_i16(0)  # Placeholder
        self._pop_stack()

        # Skip error if assertion passes
        self.current_chunk.write_byte(Opcode.JUMP)
        skip_jump = self.current_chunk.current_position()
        self.current_chunk.write_i16(0)  # Placeholder

        # Assertion failed - generate error
        fail_offset = self.current_chunk.current_position()
        if inst.message:
            msg_idx = self._add_constant(inst.message)
        else:
            msg_idx = self._add_constant("Assertion failed")
        self.current_chunk.write_byte(Opcode.LOAD_CONST)
        self.current_chunk.write_u16(msg_idx)

        # Call error function
        err_idx = self._add_constant("__error__")
        self.current_chunk.write_byte(Opcode.LOAD_FUNCTION)
        self.current_chunk.write_u16(err_idx)
        self.current_chunk.write_byte(Opcode.SWAP)
        self.current_chunk.write_byte(Opcode.CALL)
        self.current_chunk.write_byte(1)

        # End
        end_offset = self.current_chunk.current_position()

        # Patch jumps
        self._patch_jump(pass_jump, fail_offset)
        self._patch_jump(skip_jump, end_offset)

    def _load_from_value(self, value: MIRValue) -> None:
        """Generate code to load a value onto the stack.

        Args:
            value: The value to load.
        """
        if not self.current_chunk:
            return

        if isinstance(value, Constant):
            const_idx = self._add_constant(value.value)
            self.current_chunk.write_byte(Opcode.LOAD_CONST)
            self.current_chunk.write_u16(const_idx)
            self._push_stack()
        elif isinstance(value, Variable | Temp):
            if value in self.local_slots:
                slot = self.local_slots[value]
                self.current_chunk.write_byte(Opcode.LOAD_LOCAL)
                self.current_chunk.write_u16(slot.index)
                self._push_stack()
            else:
                # Global variable - strip SSA suffix if present
                var_name = value.name if hasattr(value, "name") else str(value)
                # Strip SSA suffix (e.g., "result.0" -> "result")
                if "." in var_name and var_name.split(".")[-1].isdigit():
                    var_name = var_name.rsplit(".", 1)[0]
                name_idx = self._add_constant(var_name)
                self.current_chunk.write_byte(Opcode.LOAD_GLOBAL)
                self.current_chunk.write_u16(name_idx)
                self._push_stack()

    def _store_to_value(self, value: MIRValue) -> None:
        """Generate code to store from stack to a value.

        Args:
            value: The value to store to.
        """
        if not self.current_chunk:
            return

        if isinstance(value, Variable | Temp):
            if value in self.local_slots:
                slot = self.local_slots[value]
                self.current_chunk.write_byte(Opcode.STORE_LOCAL)
                self.current_chunk.write_u16(slot.index)
                self._pop_stack()
            else:
                # Global variable - strip SSA suffix if present
                var_name = value.name if hasattr(value, "name") else str(value)
                # Strip SSA suffix (e.g., "result.0" -> "result")
                if "." in var_name and var_name.split(".")[-1].isdigit():
                    var_name = var_name.rsplit(".", 1)[0]
                name_idx = self._add_constant(var_name)
                self.current_chunk.write_byte(Opcode.STORE_GLOBAL)
                self.current_chunk.write_u16(name_idx)
                self._pop_stack()

    def _allocate_slot(self, value: MIRValue) -> StackSlot:
        """Allocate a stack slot for a value.

        Args:
            value: The value to allocate a slot for.

        Returns:
            The allocated slot.
        """
        if value not in self.local_slots:
            # For now, ignore register allocation and give each value its own slot
            # This is less efficient but ensures correctness with SSA form
            slot_index = self.next_slot_index
            self.next_slot_index += 1

            slot = StackSlot(
                slot_index,
                value.name if hasattr(value, "name") else str(value),
                value.type if hasattr(value, "type") else MIRType.UNKNOWN,
            )
            self.local_slots[value] = slot

        return self.local_slots[value]

    def _add_constant(self, value: Any) -> int:
        """Add a constant to the pool.

        Args:
            value: The constant value.

        Returns:
            Index in constant pool.
        """
        if not self.current_chunk:
            return 0

        # Use (type, value) tuple as key to distinguish between e.g. 5 and 5.0
        # This prevents Python's dictionary from treating 5 and 5.0 as the same key
        key = (type(value).__name__, value)

        # Check if already in pool
        if key in self.constant_indices:
            return self.constant_indices[key]

        # Add to pool
        idx = self.current_chunk.add_constant(value)
        self.constant_indices[key] = idx
        return idx

    def _resolve_jumps(self) -> None:
        """Resolve pending jump targets."""
        if not self.current_chunk:
            return

        for jump_offset, target_label in self.pending_jumps:
            if target_label in self.label_offsets:
                target_offset = self.label_offsets[target_label]
                offset = target_offset - jump_offset - 2
                self._patch_jump(jump_offset, jump_offset + 2 + offset)

    def _patch_jump(self, jump_offset: int, target_offset: int) -> None:
        """Patch a jump instruction with the target offset.

        Args:
            jump_offset: Offset of the jump operand.
            target_offset: Target instruction offset.
        """
        if not self.current_chunk:
            return

        self.current_chunk.patch_jump(jump_offset, target_offset)

    def _push_stack(self) -> None:
        """Track stack push."""
        self.current_stack_depth += 1
        self.max_stack_depth = max(self.max_stack_depth, self.current_stack_depth)

    def _pop_stack(self) -> None:
        """Track stack pop."""
        self.current_stack_depth = max(0, self.current_stack_depth - 1)


def generate_bytecode(mir_module: MIRModule, debug_info: DebugInfo | None = None) -> Module:
    """Generate bytecode from MIR module.

    Args:
        mir_module: The MIR module.
        debug_info: Optional debug information.

    Returns:
        Generated bytecode module.
    """
    generator = BytecodeGenerator()
    return generator.generate_module(mir_module, debug_info)
