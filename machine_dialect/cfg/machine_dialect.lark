// Machine Dialectâ„¢ Grammar for LARK Parser
// This grammar should match the exact syntax of the main parser
// CRITICAL: 100% feature parity with main parser is MANDATORY

start: program

// Allow empty programs (just whitespace/comments)
program: utility_def* statement_list
       | utility_def+  // Just utility definitions
       |               // Completely empty program

// Utility definitions (markdown style) - parsed but treated as metadata
// The parser REQUIRES the HTML_BLOCK (details/summary), so it's not optional
// The body inside the details block MUST be a proper BLOCK_CONTENT (with > prefixes)
utility_def: MARKDOWN_HEADER details_block inputs_section? outputs_section?

// Details block contains summary and block content
details_block: DETAILS_OPEN SUMMARY_LINE UTILITY_BLOCK_CONTENT DETAILS_CLOSE

// More restrictive: must be Action, Interaction, or Utility in English
// The line must end immediately after the closing backtick - no extra text allowed
// Removed the $ anchor to allow content after the header on following lines
MARKDOWN_HEADER: /###\s+(Action|Interaction|Utility):\s*`[^`]+`/

// HTML tags for details/summary structure
DETAILS_OPEN: /<details>\s*\n/
SUMMARY_LINE: /<summary>[^\n]+<\/summary>/
DETAILS_CLOSE: /<\/details>/

// Utility block content - statements prefixed with > symbols
// This matches the block body between summary and closing details tag
// Must have at least one statement line with > prefix
// Allow optional empty lines before and after the block content
UTILITY_BLOCK_CONTENT: /\n+([ \t]*>+[^\n]*\n)+\s*/

// Input parameters section with proper type enforcement
inputs_section: "####" "Inputs" ":" input_param*
input_param: "-" BACKTICK_IDENT "as"i type_name "(" ("required" | "optional") ")"

// Output values section with proper type enforcement
outputs_section: "####" "Outputs" ":" output_spec*
output_spec: "-" type_name ":" /[^\n]+/
           | "-" BACKTICK_IDENT "as"i type_name ("(" "default" ":" expression ")")?

// Allow statements with or without periods, or single expressions
statement_list: (statement ("." statement)* "."?)
              | expression       // Bare expression

statement: define_stmt
         | set_stmt
         | give_back_stmt
         | say_stmt
         | tell_stmt      // Add Tell as alias for Say
         | if_stmt
         | when_stmt      // Add When as alias for If
         | while_stmt
         | for_each_stmt
         | use_stmt       // Use is the only function call syntax
         | action_stmt
         | interaction_stmt
         | list_mutation_stmt  // Add list mutation operations

// Define statement for variable declaration
define_stmt: "Define"i identifier "as"i type_name
           | "Define"i identifier "as"i type_name "(" "default"i ":" expression ")"  // With default value

// Statements - includes type annotations and list item mutations
set_stmt: "Set"i identifier "to"i expression
        | "Set"i identifier "as"i type_name "to"i expression                   // Type annotations
        | "Set"i identifier "to"i ":" list_literal                             // List assignment
        | "Set"i identifier "using"i identifier ("with"i expression_list)?     // Set using with positional args
        | "Set"i identifier "using"i identifier ("where"i named_args)?         // Set using with named args
        | "Set"i ("the"i)? ordinal_position "item"i "of"i identifier "to"i expression  // Set ordinal item
        | "Set"i "item"i expression "of"i identifier "to"i expression          // Set numeric item

// Type names for type annotations - must match TYPING_MAP in parser
type_name: "Text"i
         | "Whole"i "Number"i
         | "Float"i
         | "Number"i
         | "Yes"i "/" "No"i
         | "URL"i
         | "Date"i
         | "DateTime"i
         | "Time"i
         | "List"i
         | "Ordered"i "List"i
         | "Unordered"i "List"i
         | "Named"i "List"i
         | "Empty"i
give_back_stmt: ("Give"i "back"i | "Gives"i "back"i) expression

// List mutation operations
list_mutation_stmt: add_stmt
                  | remove_stmt
                  | insert_stmt
                  | clear_stmt
                  | update_stmt

// Add item to list or key-value to dictionary
add_stmt: "Add"i expression "to"i identifier                                     // Add to list
        | "Add"i expression "to"i identifier "with"i "value"i? expression       // Add to dictionary

// Remove item from list or key from dictionary
remove_stmt: "Remove"i expression "from"i identifier

// Insert item at specific position in list
insert_stmt: "Insert"i expression "at"i "position"i? expression "in"i identifier

// Clear all items from collection
clear_stmt: "Clear"i identifier

// Update dictionary value for key
update_stmt: "Update"i expression "in"i identifier "to"i expression

// Ordinal positions (only these are supported)
ordinal_position: "first"i | "second"i | "third"i | "last"i
say_stmt: "Say"i expression
tell_stmt: "Tell"i expression  // Alias for Say
use_stmt: "Use"i identifier ("with"i expression_list)?  // Modern syntax
        | "Use"i identifier ("where"i named_args)?      // Named arguments

// Support for When as alias for If
when_stmt: "When"i expression "then"i ":" BLOCK_CONTENT? otherwise_clause?
otherwise_clause: "Otherwise"i ":" BLOCK_CONTENT?

// While loop
while_stmt: "While"i expression ":" BLOCK_CONTENT?

// For each loop
for_each_stmt: "For"i "each"i identifier "in"i expression ":" BLOCK_CONTENT?

// Action and Interaction with simplified blocks
// For CFG validation, we'll accept the structure but not fully parse blocks
action_stmt: "Action"i IDENTIFIER ("with"i parameter_list)? ":" BLOCK_CONTENT?
interaction_stmt: "Interaction"i IDENTIFIER ("with"i parameter_list)? ":" BLOCK_CONTENT?

// If statement with simplified blocks
if_stmt: "If"i expression "then"i ":" BLOCK_CONTENT? else_clause?
else_clause: ("Else"i | "Otherwise"i) ":" BLOCK_CONTENT?

// Parameters - supports "as Type" syntax for actions/interactions
parameter_list: parameter ("," parameter)*
parameter: identifier ("as"i IDENTIFIER)? ("=" expression)?

// Named arguments for function calls
named_args: named_arg ("," named_arg)*
named_arg: identifier "is"i expression

expression_list: expression ("," expression)*

// Expressions
expression: conditional_expr
          | or_expr

conditional_expr: or_expr "if"i or_expr "else"i or_expr

or_expr: and_expr ("or"i and_expr)*

and_expr: not_expr ("and"i not_expr)*

not_expr: "not"i not_expr
        | comparison

comparison: arith_expr (comp_op arith_expr)?

comp_op: "<=" | ">=" | "<" | ">"
       | "equals"i
       | "is"i "equal"i "to"i
       | "is"i "the"i "same"i "as"i
       | "is"i "not"i "equal"i "to"i
       | "does"i "not"i "equal"i
       | "is"i "different"i "from"i
       | "is"i "not"i type_name        // Type checking (negated)
       | "is"i "not"i
       | "is"i "strictly"i "equal"i "to"i
       | "is"i "exactly"i "equal"i "to"i
       | "is"i "identical"i "to"i
       | "is"i "not"i "strictly"i "equal"i "to"i
       | "is"i "not"i "exactly"i "equal"i "to"i
       | "is"i "not"i "identical"i "to"i
       | "is"i "greater"i "than"i "or"i "equal"i "to"i
       | "is"i "less"i "than"i "or"i "equal"i "to"i
       | "is"i "greater"i "than"i
       | "is"i "less"i "than"i
       | "is"i "more"i "than"i         // Natural language >
       | "is"i "under"i                // Natural language <
       | "is"i "at"i "least"i          // Natural language >=
       | "is"i "at"i "most"i           // Natural language <=
       | "is"i type_name                // Type checking

arith_expr: term (("+"|"-") term)*

term: power (("*"|"/") power)*

power: unary ("^" unary)*

unary: "-"+ atom -> neg
     | atom

atom: "(" expression ")"
    | literal
    | identifier
    | list_literal  // Inline list literals
    | list_access   // List item access

// Identifier must be backtick-wrapped (CFG enforces proper syntax)
identifier: BACKTICK_IDENT

// Collection access patterns
list_access: ("the"i)? ordinal_position "item"i "of"i identifier  // the first item of `list`
           | "item"i expression "of"i identifier                   // item _5_ of `list`
           | identifier "'s"i identifier                           // `dict`'s name (possessive)
           | "the"i dict_extract_type "of"i identifier             // the names/contents of `dict`

// Dictionary extraction types
dict_extract_type: "names"i | "contents"i | "keys"i | "values"i

// List literals - three types of lists
list_literal: unordered_list | ordered_list | named_list | "blank"i  // "blank" for empty list

// Unordered list: dash-prefixed items with period at end
unordered_list: ("-" expression "." )+

// Ordered list: number-prefixed items with period at end
ordered_list: (NUMBER "." expression "." )+

// Named list: key-value pairs with dash prefix and colon separator
named_list: ("-" expression ":" expression "." )+

// Number for ordered lists (any positive integer)
NUMBER: /\d+/

// Literals - parse with underscores as complete tokens
literal: LITERAL_FLOAT
       | LITERAL_INT
       | LITERAL_STRING
       | LITERAL_TRUE
       | LITERAL_FALSE
       | LITERAL_YES    // Add Yes as boolean true
       | LITERAL_NO     // Add No as boolean false
       | LITERAL_EMPTY
       | LITERAL_URL

// Literal patterns - these are complete tokens including underscores
// Support scientific notation for floats
LITERAL_FLOAT: /_-?\d+\.\d+([eE][+-]?\d+)?_/ | /_-?\d+[eE][+-]?\d+_/
LITERAL_INT: /_-?\d+_/
// Support single, double, and triple-quoted strings
LITERAL_STRING: /_"""[\s\S]*?"""_|_'''[\s\S]*?'''_|_"(?:[^"\\]|\\.)*"_|_'(?:[^'\\]|\\.)*'_/
LITERAL_TRUE: /_true_/i
LITERAL_FALSE: /_false_/i
LITERAL_YES: /_yes_/i       // Yes literal
LITERAL_NO: /_no_/i         // No literal
LITERAL_EMPTY: /_empty_/i
LITERAL_URL: /_https?:\/\/[^\s]+_/

// Backtick identifier - can contain spaces and special characters
BACKTICK_IDENT: /`[^`]+`/

// IDENTIFIER is used in action/interaction statements for names
IDENTIFIER: /[a-zA-Z][a-zA-Z0-9_]*|[a-zA-Z_][a-zA-Z0-9_]+/

// Block content - matches everything after : until end or next statement
// This is a simplified approach for CFG validation
// Supports nested blocks with multiple > markers
BLOCK_CONTENT: /(\n[ \t]*>+[^\n]*)+/

COMMENT: /#[^\n]*/

%import common.WS
%ignore WS
%ignore COMMENT
