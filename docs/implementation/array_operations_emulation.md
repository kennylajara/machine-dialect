# Array Operations Emulation Strategy

## Overview

This document describes how Machine Dialect™ emulates complex array operations (insert, remove,
find) using the existing VM opcodes, avoiding the need to modify the Rust VM.

## Implementation Status

### ✅ Completed Operations

1. **ArrayFindIndex** - Find the index of a value in an array
2. **ArrayInsert** - Insert an element at a specific position
3. **ArrayRemove** - Remove an element at a specific index

All operations are fully functional and generate executable bytecode using loop-based emulation.

## Emulation Strategies

### ArrayFindIndex(array, value) → index

Finds the first occurrence of `value` in `array`, returning its index or -1 if not found.

**Algorithm:**

```text
1. Get array length
2. Initialize index to 0
3. Loop while index < length:
   a. Get element at current index
   b. If element == value:
      - Return index
   c. Increment index
4. Return -1 (not found)
```

**VM Opcodes Used:**

- `ARRAY_LEN_R` - Get array length
- `LOAD_CONST_R` - Load constants (0, 1, -1)
- `LT_R` - Compare index < length
- `ARRAY_GET_R` - Get element at index
- `EQ_R` - Compare element with value
- `JUMP_IF_R` / `JUMP_IF_NOT_R` - Control flow
- `ADD_R` - Increment index
- `MOVE_R` - Move values between registers

**Performance:** O(n) where n is array length

### ArrayInsert(array, index, value)

Inserts `value` at position `index`, shifting subsequent elements.

**Algorithm:**

```text
1. Get original array length
2. Create new array with length + 1
3. Copy elements [0:index] to new array
4. Set new[index] = value
5. Copy elements [index:] to new[index+1:]
6. Replace original array with new array
```

**VM Opcodes Used:**

- `ARRAY_LEN_R` - Get array length
- `ADD_R` - Calculate new length
- `NEW_ARRAY_R` - Create new array
- `ARRAY_GET_R` / `ARRAY_SET_R` - Copy elements
- `LT_R` - Loop conditions
- `JUMP_R` / `JUMP_IF_NOT_R` - Loop control
- `MOVE_R` - Replace array reference

**Performance:** O(n) where n is array length

### ArrayRemove(array, index)

Removes the element at `index`, shifting subsequent elements.

**Algorithm:**

```text
1. Get original array length
2. Create new array with length - 1
3. Copy elements [0:index] to new array
4. Copy elements [index+1:] to new[index:]
5. Replace original array with new array
```

**VM Opcodes Used:**

- `ARRAY_LEN_R` - Get array length
- `SUB_R` - Calculate new length
- `NEW_ARRAY_R` - Create new array
- `ARRAY_GET_R` / `ARRAY_SET_R` - Copy elements
- `EQ_R` / `LT_R` - Loop conditions
- `JUMP_R` / `JUMP_IF_R` - Loop control
- `MOVE_R` - Replace array reference

**Performance:** O(n) where n is array length

## Register Allocation

The emulation uses high-numbered registers (247-254) as temporary storage to avoid conflicts
with user variables:

- **247-249**: Array lengths and sizes
- **250**: New array during copy operations
- **251-252**: Loop counters and element storage
- **253**: Comparison results
- **254**: Constant values (usually 1)

## Label Generation

Each emulated operation generates unique labels using a counter to avoid conflicts:

- `find_loop_N`, `find_end_N`, `find_found_N` - For ArrayFindIndex
- `insert_copy_before_N`, `insert_done_N` - For ArrayInsert
- `remove_copy_N`, `remove_done_N` - For ArrayRemove

Where N is an incrementing counter ensuring uniqueness.

## Benefits

1. **No VM Changes Required** - Works with existing VM implementation
2. **Immediate Functionality** - All list operations are now executable
3. **Correctness** - Operations behave identically to native implementations
4. **Maintainability** - Clear separation between emulated and native operations

## Limitations

1. **Performance** - O(n) operations that could potentially be O(1) with native support
2. **Code Size** - Generated bytecode is larger than native operations would be
3. **Register Pressure** - Uses several temporary registers

## Future Optimizations

When the VM is updated with native support for these operations:

1. Add new opcodes:
   - `ARRAY_INSERT_R`
   - `ARRAY_REMOVE_AT_R`
   - `ARRAY_FIND_R`

2. Update bytecode generation to use native opcodes when available

3. Keep emulation as fallback for compatibility

## Testing

All operations are tested through:

- Unit tests in `machine_dialect/mir/tests/test_collection_lowering.py`
- Integration tests for end-to-end compilation
- Manual verification of generated bytecode

## Example Usage

```markdown
# Insert operation
Define `items` as Ordered List.
Set `items` to:
1. _"first"_.
2. _"second"_.

Insert _"new"_ at position _2_ in `items`.

# Remove by value
Define `fruits` as Unordered List.
Set `fruits` to:
- _"apple"_.
- _"banana"_.

Remove _"apple"_ from `fruits`.
```

Both examples compile to executable bytecode that correctly manipulates the arrays.
